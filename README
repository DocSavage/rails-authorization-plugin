= Authorization plugin
Version 1.0 rc1
June 21, 2006

http://www.writertopia.com/developers/authorization

This plugin provides a flexible way to add authorization to Rails.

The authorization process decides whether a user is allowed access to some feature. 
It is distinct from the authentication process, which tries to confirm a user is 
authentic, not an imposter. There are many authentication systems available for Rails, 
e.g., acts_as_authenticated and UserEngine. This authorization system 
will play nicely with them as long as some simple requirements are met:

1. User objects are available that implement a <tt>has_role?(role, authorizable_object = nil)</tt> method. This requirement can be easily handled by using <tt>acts_as_authorized_user</tt> in the User-like class.
   
2. If you want to use "role of :model" authorization expressions, like "owner of :resource" or "eligible for :award", then your models with roles must implement an <tt>accepts_role?(role, user)</tt> method. This requirement can be handled by using <tt>acts_as_authorizable</tt> in the model class.
   
Change the constants at the top of lib/authorization.rb to set your authentication
system's login page and method for storing the current URL for return after authentication.

== Steps in using the plugin

1. At the top of your config/environment.rb create an AUTHORIZATION_MIXIN constant and set it to "object roles" or "hardwired". See init.rb in this plugins.
2. Depending on the mixin you use, create a migration to add the necessary database tables. If you use the "hardwired" mixin, no database use is required. Otherwise, you'll have to add a <tt>roles_users</tt> and <tt>roles</tt> table. Sample migrations are provided at the top of each mixin (e.g., object_roles_table.rb)
3. Make sure your application provides the following: (a) #current_user method or something that returns the current user object. (b) the login page url hash is set in authorization.rb under the constant DEFAULT_REDIRECTION_HASH.
4. Add <tt>acts_as_authorized_user</tt> to your user class.
5. Add <tt>acts_as_authorizable</tt> to the models you want to query for roles.

== Jumpstarting with a mixin


The Authorization plugin comes with three modules that provide different levels of database support.
Each of the mixins provide the "acts_as_authorized_user" and "acts_as_authorizable" class methods
for your models. If you use one of those declarations, you get methods that handle authorization
with different database schemes. A full test web application is provided for each of the modules
so you can see how they work. The "Object Roles Table" version is recommended for normal use and
is the default. The other mixins are provided for pedagogical reasons.

=== 1) Hardwired Roles

This is the simplest and requires no database. Roles are assumed to be coded into the Model classes
using the <tt>has_role?(role, obj = nil)</tt> method.

=== 2) Simple Roles Table

Roles have a has_and_belongs_to_many (habtm) relationship with Users. Roles have string names and
are not associated with any model instances. Because roles aren't associated with any model instance,
this mixin can't support "role of :model" authorization expressions through the database. You can,
however, support those expressions by writing code in models' <tt>has_role?</tt> methods.

=== 3) Object Roles Table

The Object Roles Table mixin provides full support for authorization expressions within a database by
add a polymorphic field to the Role table. Because roles have polymorphic associations to an
authorizable object, we can assign a user to a role for any model instance. So you could declare user X
to be a moderator for workshop Y, or you could make user A be the owner of resource B.

Each mixin's test web application comes with migrations to set up the database for the associated mixin.
After reading the Rails Recipe on domain specific languages (DSLs) for testing, I added integration tests
for each mixin test app that use a simple vocabulary for testing authorization.


== The Specifics

=== permit and permit?

permit and permit? take an authorization expression and a hash of options 
that typically includes any objects that need to be queried:

  permit <authorization expression> [, options hash ]
  permit? <authorization expression> [, options hash ]

The difference between permit and permit? is redirection. permit is a declarative 
statement and redirects by default. It can also be used as a class or an
instance method, gating the access to an entire controller in a before_filter fashion.

permit? is only an instance method, can be used within expressions, does not redirect by default.

The authorization expression is a boolean expression made up of permitted roles, prepositions,
and authorizable models. Examples include "admin" (User model assumed), "moderator of :workshop" 
(looks at options hash and then @workshop), "'top salesman' at :company" (multiword roles delimited 
by single quotes), or "scheduled for Exam" (queries class method of Exam).

Note that we can use several permitted prepositions (of, for, by, to, at). In the discussion below,
we assume you use the "of" preposition. You can modify the permitted prepositions by changing the constant
in Authorization::Base::Parser.

* If a specified role has no "of <model>" designation, we assume it is a user role (i.e., the model is the user-like object). 
* If an "of :model" designation is given but no ":model" key/value is supplied in the hash, we check if an instance variable @model if it's available.
* If the model has no preceding colon, we assume it's a class and query Model#self.accepts_role? (the class method) for the permission.
(Currently only available in ObjectRolesTable mixin.)

For each role, a query is sent to the appropriate model object.

The grammar for the authorization expression is:

             <expr> ::= (<expr>) | not <expr> | <term> or <expr> | <term> and <expr> | <term>
             <term> ::= <role> | <role> <preposition> <model>
      <preposition> ::= of | for | in | on | to | at | by
            <model> ::= /:\w+/
             <role> ::= /\w+/ | /'.*'/
		
Parentheses should be used to clarify permissions. 
The expression "a or b and c or d" gets parsed like "a or (b and (c or d))" if you use the RecursiveDescentParser mixin.
(The EvalParser uses Ruby's eval and presumably won't suffer from this parsing issue.)

==== Options

<tt>:allow_guests => false</tt>. We can allow permission processing without a current user object. The default is <tt>false</tt>.

<tt>:user</tt> => A <tt>user</tt> object.

<tt>:get_user_method => method</tt> that will return a <tt>user</tt> object. Default is <tt>#current_user</tt>, which is the how <tt>acts_as_authenticated</tt> works.

<tt>:only => [ :method1, :method2 ]</tt>. Array of methods to apply permit (not valid when used in instance methods)

<tt>:except => [ :method1, :method2 ]</tt>. Array of methods that won't have permission checking (not valid when used in instance methods)

<tt>:redirect => bool</tt>. default is <tt>true</tt>. If <tt>false</tt>, permit will not redirect to denied page.

<tt>:redirect_action => action</tt> that handles authorization failure (default is 'account')

<tt>:redirect_controller => controller</tt> that handles authorization failure (default is 'denied')

=== Setting the roles

Roles are set by #has_role and #accepts_role methods that are mixed into the User-like object 
and the authorizable models. User objects can set roles and optionally an object scope for
that role:

	user.has_role 'site_admin'
	user.has_role 'moderator', workshop
	user.has_no_role 'site_admin'
	user.has_no_role 'moderator', workshop
	
(TODO: Add full support for class scope by passing in a Class instead of an model instance.)

Models set roles for specific users:

	a_model.accepts_role 'moderator', user
	a_model.accepts_no_role 'moderator', user

The method language has been chosen to aid memory of the argument order. A user has a role "foo",
so the role string immediately follows has_role. Similarly, a model accepts a role "foo", so
the role string immediately follows accepts_role. Then we append the scope.

Sometimes the user-like object might be an authorizable object as well, for example, when you 
allow 'friend' roles for users.

The Object Roles Table mixin version includes some dynamic methods that use the roles table.
For example, if you have roles like "eligible", "moderator", and "owner", you'll be able to
use the following:

user.is_eligible_for_what   # --> returns array of authorizable objects for which user has role "eligible"
user.is_moderator_of? workshop  # --> returns true/false
user.is_moderator_of workshop   # --> sets user to have role "moderator" for object workshop.
user.is_administrator  # --> sets user to have role "administrator" not really tied to any object.

=== Pattern of use

We expect the application to provide the following methods:

==== #current_user
Returns some user object, like an instance of my favorite class, <tt>UserFromMars</tt>. 
A <tt>user</tt> object, from the Authorization viewpoint, is simply an object that 
provides a #has_role? method.

Note that duck typing means we don't care what else the <tt>UserFromMars</tt> might be doing. 
We only care that we can get an id from whatever it is, and we can check if a given 
role string is associated with it. By using <tt>acts_as_authorized_user</tt>, we inject what
we need into the user object.

If you use an authorization expression "admin of :foo", we check permission by 
asking <tt>foo</tt> if it <tt>accepts_role?('admin', user)</tt>. So for each model that is used in an 
expression, we assume that it provides the <tt>accepts_role?(role, user)</tt> method.

Note that <tt>user</tt> can be <tt>nil</tt> if <tt>:allow_guests => true</tt>. 

==== #store_return_location (optional)

This method will be called if authorization fails and the user is about to be redirected to 
the login action. This allows the application to return to the desired page after login.
If the application doesn't provide this method, the method will not be called.

The name of the method for storing a location can be modified by changing the constant
STORE_LOCATION_METHOD in authorization.rb. Also, the default login page is defined by
the constant DEFAULT_REDIRECTION_HASH in authorization.rb. I'll probably have a better
constant setting method so the plugin can remain intact.

=== Conventions

Roles specified without the "of :model" designation:

1. We see if there is a <tt>#current_user</tt> method available that will return a user object. This method can be overridden with the <tt>:user</tt> hash.
2. Once a user object is determined, we pass the role to user#has_role? and expect a true return value if the user has the given role.

Roles specified with "of :model" designation:

1. We attempt to query an object in the options hash that has a matching key. Example: <tt>permit "knight for :justice", :justice => @abstract_idea</tt>
2. If there is no object with a matching key, we see if there's a matching instance variable. Example: @meeting defined before we use <tt>permit "moderator of :meeting"</tt>
3. Once the model object is determined, we pass the role and user (determined in the manner above) to model#accepts_role?

=== More information

Information on this plugin and other development can be found at http://www.writertopia.com/developers

